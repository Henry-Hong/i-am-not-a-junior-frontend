/**
 * 솔루션 개요
경로를 완전탐색(DFS/BFS)으로 모두 확인해볼 수도 있지만, **동적 계획법(DP)**으로 더 효율적으로 구할 수 있습니다.
이 문제의 핵심은 “(r, c)까지 왔을 때 만들 수 있는 가장 큰 문자열(숫자)”를 구해두고, 이를 바탕으로 다음 칸을 갱신하는 방식입니다.

아래에서는 크게 두 가지 방법을 소개하겠습니다.

Top-Down(재귀 + 메모이제이션) 방식
Bottom-Up(반복문) 방식
두 방식 모두 결과적으로 (N-1, M-1) 위치에 도달했을 때의 “가장 큰 문자열”을 구할 수 있습니다.
다만 구현 스타일(재귀 vs 반복)과 DP 배열을 채우는 순서에서 차이가 있습니다.

첫 번째 솔루션: Top-Down (DFS + 메모이제이션)
(r, c)에 도달했을 때 만들 수 있는 “가장 큰 수(문자열)”를 dp[r][c]에 저장.
만약 이미 dp[r][c]를 구했다면, 재계산하지 않고 바로 반환(메모이제이션).
(0,0)에서 시작하여 (N-1, M-1)에 도착할 때까지, 가능한 모든 경로 중 최대값을 탐색.
경로는 항상 같은 길이를 가지므로, 문자열 비교 시 단순히 사전순으로 비교하면 됨.


시간 복잡도
각 칸 (r, c)에 대해 dfs(r, c)가 한 번씩만 유효 연산을 수행합니다.
각 칸을 방문할 때마다 문자열 합치기 연산이 일어나므로, 이 부분을 주의해야 합니다.
하지만 모든 경로 길이는 동일하고, 각 칸은 최대 한 번씩만 최종 문자열을 만든 뒤 메모이제이션하므로,
전체적으로 O(N*M*(N+M)) 정도로 볼 수 있습니다(문자열 병합 비용 포함).
특징
재귀 코드이므로 직관적으로 “위나 왼쪽에서 온 최대 문자열 + 현재 숫자”라는 점이 잘 드러남.
재귀 호출 스택이 깊어질 수 있으므로, N, M이 큰 경우 스택오버플로에 주의해야 함.

 */

/**
 * (재귀 + 메모이제이션)으로 가장 큰 경로 숫자 문자열을 구한다.
 * @param {number[][]} board - 2차원 배열 (N행 M열)
 * @returns {string} - 이어붙였을 때 만들 수 있는 가장 큰 수를 문자열 형태로 반환
 */
function getMaxNumberPathTopDown(board) {
  const N = board.length;
  const M = board[0].length;

  // dp[r][c]: (r, c)에 도달했을 때 만들 수 있는 가장 큰 수(문자열)
  const dp = Array.from({ length: N }, () => Array(M).fill(null));

  // 재귀 함수
  function dfs(r, c) {
    // 범위를 벗어나면 빈 문자열 반환
    if (r < 0 || c < 0) return null;

    // (0,0)에 도착한 경우, 해당 숫자를 문자열로 반환
    if (r === 0 && c === 0) {
      return String(board[r][c]);
    }

    // 이미 계산된 적이 있다면 그 결과 반환
    if (dp[r][c] !== null) {
      return dp[r][c];
    }

    // 위쪽 칸에서 오는 경우와 왼쪽 칸에서 오는 경우 비교
    const fromTop = r > 0 ? dfs(r - 1, c) : null;
    const fromLeft = c > 0 ? dfs(r, c - 1) : null;

    // 두 후보 중 사전순으로 더 큰 문자열을 선택
    let bestPrev = "";
    if (fromTop && fromLeft) {
      bestPrev = fromTop > fromLeft ? fromTop : fromLeft;
    } else if (fromTop) {
      bestPrev = fromTop;
    } else if (fromLeft) {
      bestPrev = fromLeft;
    }

    // 현재 칸의 숫자를 이어붙임
    dp[r][c] = bestPrev + String(board[r][c]);
    return dp[r][c];
  }

  // (N-1, M-1)까지의 최대 문자열을 구한다.
  return dfs(N - 1, M - 1);
}

// 사용 예시
(function testTopDown() {
  const board = [
    [2, 5, 1],
    [3, 9, 7],
    [6, 8, 2],
  ];
  console.log(getMaxNumberPathTopDown(board));
  // 예: "25972"
})();

/***********************************************/

/**
 * (0, 0)부터 시작해 (N-1, M-1)까지 순차적으로 채워나가는 방식.
dp[r][c]는 (0,0)에서 (r,c)까지 도달하는 경로 중 만들어질 수 있는 가장 큰 문자열.
초기값 dp[0][0] = board[0][0].toString().
각 단계에서 dp[r][c] = max(dp[r-1][c], dp[r][c-1]) + board[r][c] (단, 범위 체크).
최종적으로 dp[N-1][M-1]이 답.

시간 복잡도
이 방식 역시 각 칸을 한 번씩만 방문하며, 각 방문 시 문자열 병합 및 비교를 합니다.
마찬가지로 O(N*M*(N+M)) 정도로 추정할 수 있습니다(경로 길이가 N+M-1이므로, 문자열 비교/합치기 비용 포함).
특징
반복문 기반이라 재귀 스택 문제는 없음.
실제로는 DP 테이블에 문자열을 직접 저장하므로, 메모리 사용량이 커질 수 있음(N, M이 큰 경우).
경로가 매우 길 경우(예: 1,000×1,000)에는 문자열 처리 비용이 커질 수 있으므로,
더 최적화된 자료구조(예: 트라이, 연결리스트 등)를 고려하거나,
파이썬 같은 언어에서는 문자열 대신 리스트에 담아 마지막에 join하는 방식도 고민할 수 있습니다.
(자바스크립트에서도 비슷하게 최적화 가능)

 */

/**
 * (반복문)으로 가장 큰 경로 숫자 문자열을 구한다.
 * @param {number[][]} board - 2차원 배열 (N행 M열)
 * @returns {string} - 이어붙였을 때 만들 수 있는 가장 큰 수를 문자열 형태로 반환
 */
function getMaxNumberPathBottomUp(board) {
  const N = board.length;
  const M = board[0].length;

  // dp[r][c]: (r, c)에 도달했을 때 만들 수 있는 가장 큰 수(문자열)
  const dp = Array.from({ length: N }, () => Array(M).fill(""));

  // 시작점 초기화
  dp[0][0] = String(board[0][0]);

  // 첫 행 초기화 (오른쪽으로만 이동 가능)
  for (let c = 1; c < M; c++) {
    dp[0][c] = dp[0][c - 1] + String(board[0][c]);
  }

  // 첫 열 초기화 (아래쪽으로만 이동 가능)
  for (let r = 1; r < N; r++) {
    dp[r][0] = dp[r - 1][0] + String(board[r][0]);
  }

  // 나머지 셀 채우기
  for (let r = 1; r < N; r++) {
    for (let c = 1; c < M; c++) {
      const top = dp[r - 1][c];
      const left = dp[r][c - 1];

      // 사전순 비교로 더 큰 문자열을 선택
      if (top > left) {
        dp[r][c] = top + String(board[r][c]);
      } else {
        dp[r][c] = left + String(board[r][c]);
      }
    }
  }

  // 결과 반환
  return dp[N - 1][M - 1];
}

// 사용 예시
(function testBottomUp() {
  const board = [
    [2, 5, 1],
    [3, 9, 7],
    [6, 8, 2],
  ];
  console.log(getMaxNumberPathBottomUp(board));
  // 예: "25972"
})();

/**
 * 두 솔루션 비교
Top-Down (재귀 + 메모이제이션)

장점: 구현이 직관적, 필요할 때만 계산한다(게으른 계산).
단점: N, M이 큰 경우 스택 오버플로 위험, 재귀함수 호출 부담.
Bottom-Up (반복문)

장점: 재귀 스택 문제 없음, 로직 흐름이 명확.
단점: 모든 칸을 순회하면서 DP 테이블을 채워야 하므로, N×M 크기가 매우 클 경우 메모리 사용량 커짐.
실제로는 문제 크기에 따라 둘 중 더 편한 구현을 택하면 되고,
둘 다 시간 복잡도는 유사합니다(모든 칸을 1회씩 처리).

추가 팁
모든 경로가 같은 길이(N+M-1)를 가지므로, 문자열 길이는 전부 동일합니다.
따라서 단순 사전순 비교(stringA > stringB)가 곧 “더 큰 숫자”를 의미합니다.
N, M이 매우 큰 경우, 문자열을 매번 합치는 것은 비효율적일 수 있습니다.
자바스크립트에서는 문자열이 immutable이라, 계속해서 + 연산이 일어나면 내부적으로 새로운 문자열을 매번 생성합니다.
최적화를 위해 경로를 저장하는 대신, “어느 경로에서 왔는지”를 별도 배열에 기록해두고, 마지막에 역추적(backtracking)하며 문자열을 한 번에 만드는 기법도 가능합니다(메모리 사용량 절감).
문제 조건이 단순 이동(오른쪽/아래)인 경우, 경로의 길이가 고정되어 있으므로,
**DP 배열에 "직전 경로의 인덱스"**만 저장해두고 최종에 복원(backtrack)하는 것도 좋은 방법입니다.
결론
위 문제를 자바스크립트로 해결하기 위해서는
(1) 재귀 + 메모이제이션(Top-Down) 또는 (2) 반복문을 활용한 Bottom-Up 방식 모두 가능하며,
두 방식 모두 O(N*M*(N+M)) 내로 해결할 수 있습니다.

직관적인 재귀를 선호한다면 Top-Down
스택오버플로 없이 명확한 흐름을 원한다면 Bottom-Up
상황에 따라 선택해 사용하시면 됩니다.
 */
